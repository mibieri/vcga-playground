extension FloorVolume --> FloorVolume.
extension Footprint1 --> Floors(1)
extension Footprint2 --> Floors(2)
extension Footprint3 --> Floors(3)
extension Footprint4 --> Floors(4)
extension Footprint5 --> Floors(5)
extension Footprint6 --> Floors(6)
extension Footprint7 --> Floors(7)
extension Footprint8 --> Floors(8)

@Group("General", 0)
@Order(0)
@Enum(valuesAttr=_enum_edgeSelection)
attr Edges = labelEdge_all

@Order(1)
@Enum(valuesAttr=_enum_fillPattern)
attr FillPattern = labelPattern_absolute

@Order(2)
@Percent
attr StartPosition = 0.0

@Order(3)
@Percent
attr Length = 1.0


@Group("Element Lengths", 10)
@Order(10)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element1_Length = 20

@Order(11)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element2_Length = 10

@Order(12)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element3_Length = 20

@Order(13)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element4_Length = 10

@Order(14)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element5_Length = 0

@Order(15)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element6_Length = 0

@Order(16)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element7_Length = 0

@Order(17)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element8_Length = 0


@Group("Element Widths", 20)
@Order(20)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element1_Width = 10

@Order(21)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element2_Width = 0

@Order(22)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element3_Width = 10

@Order(23)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element4_Width = 0

@Order(24)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element5_Width = 0

@Order(25)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element6_Width = 0

@Order(26)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element7_Width = 0

@Order(27)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element8_Width = 0


@Group("Element Insets", 30)
@Order(30)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element1_Inset = 0

@Order(31)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element2_Inset = 0

@Order(32)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element3_Inset = 0

@Order(33)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element4_Inset = 0

@Order(34)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element5_Inset = 0

@Order(35)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element6_Inset = 0

@Order(36)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element7_Inset = 0

@Order(37)
@Range(min=0, max=100, stepsize=0.1, restricted=false)
attr Element8_Inset = 0


@Group("Floors", 40)
@Order(39)
@Range(min=0, max=10, stepsize=0.1, restricted=false)
attr FloorHeight = 3.0

@Order(40)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element1_Num_Floors = 2

@Order(41)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element2_Num_Floors = 0

@Order(42)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element3_Num_Floors = 4

@Order(43)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element4_Num_Floors = 0

@Order(44)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element5_Num_Floors = 0

@Order(45)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element6_Num_Floors = 0

@Order(46)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element7_Num_Floors = 0

@Order(47)
@Range(min=0, max=30, stepsize=1, restricted=false)
attr Element8_Num_Floors = 0


const labelEdge_all = "All Edges"
const labelEdge_first = "First Edge"
const labelEdge_longest = "Longest Edge"
const labelEdge_setbackFront = "Setback: Front of Setback Face"
const labelEdge_setbackBack = "Setback: Back of Setback Face"
const labelEdge_parcelFront = "Shape: Front"
const labelEdge_parcelBack = "Shape: Back"
const labelEdge_parcelRight = "Shape: Right"
const labelEdge_parcelLeft = "Shape: Left"
const labelEdge_orientationFront = "Edge Attribute: Front"
const labelEdge_orientationRear = "Edge Attribute: Rear"
const labelEdge_orientationSide = "Edge Attribute: Side"

const labelPattern_absolute = "No Fill"
const labelPattern_absoluteRepeat = "Repeat"
const labelPattern_relative = "Strech to Fill"


@Hidden
attr _enum_edgeSelection = [
	labelEdge_all,
	labelEdge_first,
	labelEdge_longest,
	labelEdge_setbackFront,
	labelEdge_setbackBack,
	labelEdge_parcelFront,
	labelEdge_parcelBack,
	labelEdge_parcelRight,
	labelEdge_parcelLeft,
	labelEdge_orientationFront,
	labelEdge_orientationRear,
	labelEdge_orientationSide
]

@Hidden
attr _enum_fillPattern = [
	labelPattern_absolute,
	labelPattern_absoluteRepeat,
	labelPattern_relative
]

const elementWidths = [
	Element1_Width, Element2_Width, Element3_Width, Element4_Width, 
	Element5_Width, Element6_Width, Element7_Width, Element8_Width 
]

const elementInsets = [
	Element1_Inset, Element2_Inset, Element3_Inset, Element4_Inset,
	Element5_Inset, Element6_Inset, Element7_Inset, Element8_Inset
]

const elementNumFloors = [
	Element1_Num_Floors, Element2_Num_Floors, Element3_Num_Floors, Element4_Num_Floors,
	Element5_Num_Floors, Element6_Num_Floors, Element7_Num_Floors, Element8_Num_Floors
]

const maxSetback with(
	setbacks := elementInsets .+ elementWidths
) = setbacks[sortIndices(setbacks)[size(setbacks) - 1]]

markLargest(inputArray) = markLargestRecursive(inputArray, sortIndices(inputArray)[size(inputArray) - 1], boolArray())
markLargestRecursive(inputArray, largestIndex, resultArray) =
	case size(resultArray) == size(inputArray): 
		resultArray
	else: 
		markLargestRecursive(
			inputArray, largestIndex, 
			[resultArray, case size(resultArray) == largestIndex: true else: false]
		)
		
getSetbackFrontMask() = comp(fe){isTagged("setback.front"): true | all: false}

getEdgeMask() = 
	case Edges == labelEdge_all:
		comp(fe){all: true}
	case Edges == labelEdge_first:
		comp(fe){0: true | all: false}
	case Edges == labelEdge_longest:
		markLargest(comp(fe){all: geometry.boundaryLength})
	case Edges == labelEdge_setbackFront:
		getSetbackFrontMask() 
	case Edges == labelEdge_setbackBack:
		comp(fe){isTagged("setback.back"): true | all: false}
	case Edges == labelEdge_parcelFront:
		comp(fe){front: true | all: false}
	case Edges == labelEdge_parcelRight:
		comp(fe){right: true | all: false}
	case Edges == labelEdge_parcelLeft:
		comp(fe){left: true | all: false}
	case Edges == labelEdge_parcelBack:
		comp(fe){back: true | all: false}
	case Edges == labelEdge_orientationFront:
		comp(fe){all: edgeAttr.getString("orientations") == "front"}
	case Edges == labelEdge_orientationRear:
		comp(fe){all: edgeAttr.getString("orientations") == "rear"}
	case Edges == labelEdge_orientationSide:
		comp(fe){all: edgeAttr.getString("orientations") == "side"}
	else:
		comp(fe){all: true}
		
getStartOfTrueEdges(mask) = getStartOfTrueEdgesRecursive(mask, 0, 0)
getStartOfTrueEdgesRecursive(mask, candidate, recursionCount) = 
	case recursionCount >= size(mask): 
		candidate
	case !mask[recursionCount]:
		getStartOfTrueEdgesRecursive(mask, (recursionCount + 1) % size(mask), recursionCount + 1)
	else:
		getStartOfTrueEdgesRecursive(mask, candidate, recursionCount + 1)

start Start -->
	splitAndSetbackPerimeter(0, 0, getEdgeMask()){
		'StartPosition: 0 : NIL |
		'Length: maxSetback : X. Pattern
	}{remainder: NIL}
	
f() = print(comp(fe){all: str(geometry.tags("setback"))})

Pattern with(
	setbackFrontMask := getSetbackFrontMask()
	firstFrontEdge := print(getStartOfTrueEdges(print(setbackFrontMask)))
)-->
	case FillPattern == labelPattern_absolute:
		splitAndSetbackPerimeter(0, 0, setbackFrontMask){
			Element1_Length : Element1_Width + Element1_Inset : Inset(1) |
			Element2_Length : Element2_Width + Element2_Inset: Inset(2) |
			Element3_Length : Element3_Width + Element3_Inset: Inset(3) |
			Element4_Length : Element4_Width + Element4_Inset: Inset(4) |
			Element5_Length : Element5_Width + Element5_Inset: Inset(5) |
			Element6_Length : Element6_Width + Element6_Inset: Inset(6) |
			Element7_Length : Element7_Width + Element7_Inset: Inset(7) |
			Element8_Length : Element8_Width + Element8_Inset: Inset(8)
		}{remainder: NIL}
	case FillPattern == labelPattern_absoluteRepeat:
		splitAndSetbackPerimeter(0, 0, setbackFrontMask){
			Element1_Length : Element1_Width + Element1_Inset : Inset(1) |
			Element2_Length : Element2_Width + Element2_Inset: Inset(2) |
			Element3_Length : Element3_Width + Element3_Inset: Inset(3) |
			Element4_Length : Element4_Width + Element4_Inset: Inset(4) |
			Element5_Length : Element5_Width + Element5_Inset: Inset(5) |
			Element6_Length : Element6_Width + Element6_Inset: Inset(6) |
			Element7_Length : Element7_Width + Element7_Inset: Inset(7) |
			Element8_Length : Element8_Width + Element8_Inset: Inset(8)
		}*{remainder: NIL}
	case FillPattern == labelPattern_relative:
		splitAndSetbackPerimeter(0, 0, setbackFrontMask){
			~Element1_Length : Element1_Width + Element1_Inset : Inset(1) |
			~Element2_Length : Element2_Width + Element2_Inset: Inset(2) |
			~Element3_Length : Element3_Width + Element3_Inset: Inset(3) |
			~Element4_Length : Element4_Width + Element4_Inset: Inset(4) |
			~Element5_Length : Element5_Width + Element5_Inset: Inset(5) |
			~Element6_Length : Element6_Width + Element6_Inset: Inset(6) |
			~Element7_Length : Element7_Width + Element7_Inset: Inset(7) |
			~Element8_Length : Element8_Width + Element8_Inset: Inset(8)
		}{remainder: NIL}
	else:
		NIL

Inset(elementIndex) -->
	setback(comp(fe){isTagged("setback.front"): elementInsets[elementIndex - 1]}){
		all: NIL | remainder: Footprint(elementIndex)
	}

Footprint(elementIndex) -->
	case elementIndex == 1: Footprint1
	case elementIndex == 2: Footprint2
	case elementIndex == 3: Footprint3
	case elementIndex == 4: Footprint4
	case elementIndex == 5: Footprint5
	case elementIndex == 6: Footprint6
	case elementIndex == 7: Footprint7
	case elementIndex == 8: Footprint8
	else: NIL
	

Floors(elementIndex) -->
	extrude(FloorHeight * elementNumFloors[elementIndex - 1])
	split(y){
		~FloorHeight: FloorVolume.
	}*
